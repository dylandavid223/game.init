<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Horizon Browser: Mexico Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --primary: #4cc9f0;
            --secondary: #4361ee;
            --accent: #f72585;
            --success: #4ade80;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1e293b;
            --darker: #0f172a;
            --light: #f8fafc;
            --gray: #64748b;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, var(--darker) 0%, #1e1b4b 100%);
            color: var(--light);
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--darker);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        
        .loader {
            width: 80px;
            height: 80px;
            border: 5px solid var(--gray);
            border-top: 5px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .progress-bar {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 20px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
            transition: width 0.3s;
        }
        
        /* Main Game UI */
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        /* Top Bar */
        #topBar {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: all;
        }
        
        .player-info {
            background: rgba(15, 23, 42, 0.9);
            padding: 12px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(76, 201, 240, 0.2);
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .player-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
        }
        
        .player-stats {
            display: flex;
            gap: 15px;
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--gray);
            margin-bottom: 4px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--light);
        }
        
        .stat-unit {
            font-size: 12px;
            color: var(--gray);
            margin-left: 2px;
        }
        
        /* Game Info */
        .game-info {
            display: flex;
            gap: 15px;
        }
        
        .info-card {
            background: rgba(15, 23, 42, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(76, 201, 240, 0.1);
            text-align: center;
            min-width: 100px;
        }
        
        /* Speedometer */
        #speedometer {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(15, 23, 42, 0.9);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(76, 201, 240, 0.2);
            pointer-events: all;
        }
        
        .speed-display {
            display: flex;
            align-items: baseline;
            margin-bottom: 10px;
        }
        
        .speed-value {
            font-size: 64px;
            font-weight: 800;
            color: var(--light);
            line-height: 1;
        }
        
        .speed-unit {
            font-size: 20px;
            color: var(--gray);
            margin-left: 8px;
        }
        
        .gear-display {
            font-size: 24px;
            font-weight: 600;
            color: var(--primary);
            text-align: center;
            margin-bottom: 10px;
        }
        
        .rpm-bar {
            width: 200px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .rpm-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--warning), var(--danger));
            width: 0%;
            transition: width 0.1s;
        }
        
        /* Minimap */
        #minimapContainer {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 200px;
            height: 200px;
            background: rgba(15, 23, 42, 0.9);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(76, 201, 240, 0.2);
            pointer-events: all;
        }
        
        .minimap-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--gray);
        }
        
        #minimapCanvas {
            width: 100%;
            height: calc(100% - 30px);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
        }
        
        /* Center Notifications */
        #notificationCenter {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            pointer-events: none;
        }
        
        .notification {
            background: rgba(15, 23, 42, 0.95);
            padding: 15px 30px;
            border-radius: 12px;
            border-left: 4px solid var(--primary);
            backdrop-filter: blur(10px);
            transform: translateY(-20px);
            opacity: 0;
            animation: slideIn 0.3s ease forwards;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }
        
        @keyframes slideIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .notification-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--light);
            margin-bottom: 4px;
        }
        
        .notification-message {
            font-size: 14px;
            color: var(--gray);
        }
        
        /* Event Progress */
        #eventProgress {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.9);
            padding: 15px 25px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(76, 201, 240, 0.3);
            min-width: 300px;
            text-align: center;
            pointer-events: all;
        }
        
        .event-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 5px;
        }
        
        .event-description {
            font-size: 14px;
            color: var(--gray);
            margin-bottom: 10px;
        }
        
        .progress-container {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
            transition: width 0.3s;
        }
        
        /* Bottom Controls */
        #controlsPanel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: all;
        }
        
        .control-button {
            background: rgba(15, 23, 42, 0.9);
            color: var(--light);
            border: 1px solid rgba(76, 201, 240, 0.3);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-button:hover {
            background: rgba(76, 201, 240, 0.2);
            transform: translateY(-2px);
        }
        
        .control-button:active {
            transform: translateY(0);
        }
        
        /* Car Selection Screen */
        #carSelection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--darker) 0%, #1e1b4b 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 500;
            padding: 40px;
        }
        
        .selection-header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        .selection-title {
            font-size: 48px;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        
        .selection-subtitle {
            font-size: 18px;
            color: var(--gray);
        }
        
        .car-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
            max-width: 1200px;
            margin-bottom: 40px;
        }
        
        .car-card {
            background: rgba(15, 23, 42, 0.8);
            border-radius: 20px;
            padding: 30px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            backdrop-filter: blur(10px);
        }
        
        .car-card:hover {
            border-color: var(--primary);
            transform: translateY(-10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        .car-card.selected {
            border-color: var(--primary);
            background: rgba(76, 201, 240, 0.1);
        }
        
        .car-icon {
            font-size: 60px;
            margin-bottom: 20px;
        }
        
        .car-name {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--light);
        }
        
        .car-specs {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .spec-item {
            text-align: center;
        }
        
        .spec-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--primary);
        }
        
        .spec-label {
            font-size: 12px;
            color: var(--gray);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .car-description {
            color: var(--gray);
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .select-button {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .select-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 20px rgba(76, 201, 240, 0.3);
        }
        
        /* Pause Menu */
        #pauseMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        .pause-title {
            font-size: 48px;
            font-weight: 800;
            color: var(--light);
            margin-bottom: 40px;
        }
        
        .menu-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 300px;
        }
        
        .menu-option {
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .menu-option:hover {
            background: rgba(76, 201, 240, 0.3);
            transform: translateY(-2px);
        }
        
        /* Performance Stats Overlay */
        #performanceStats {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(15, 23, 42, 0.9);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(76, 201, 240, 0.2);
            display: none;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .stat-row {
            font-size: 12px;
        }
        
        .stat-name {
            color: var(--gray);
        }
        
        .stat-value {
            color: var(--light);
            font-weight: 600;
        }
        
        /* Damage Indicator */
        #damageIndicator {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            display: none;
        }
        
        .damage-bar {
            width: 20px;
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .damage-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to top, var(--success), var(--warning), var(--danger));
        }
        
        /* Achievement Popup */
        #achievementPopup {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(15, 23, 42, 0.95);
            padding: 15px;
            border-radius: 12px;
            border-left: 4px solid var(--warning);
            display: none;
            backdrop-filter: blur(10px);
            max-width: 300px;
            animation: slideIn 0.3s ease;
        }
        
        .achievement-icon {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .achievement-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--light);
            margin-bottom: 5px;
        }
        
        .achievement-desc {
            font-size: 14px;
            color: var(--gray);
        }
        
        /* Adaptive Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: none;
            justify-content: space-between;
            pointer-events: all;
        }
        
        .mobile-control-group {
            display: flex;
            gap: 10px;
        }
        
        .mobile-button {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            touch-action: none;
            user-select: none;
        }
        
        .mobile-stick {
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }
        
        .stick-handle {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 30px;
            left: 30px;
        }
        
        /* Responsive */
        @media (max-width: 1024px) {
            .car-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            #speedometer {
                left: 20px;
                bottom: 20px;
                padding: 15px;
            }
            
            .speed-value {
                font-size: 48px;
            }
        }
        
        @media (max-width: 768px) {
            .car-grid {
                grid-template-columns: 1fr;
            }
            
            #minimapContainer {
                width: 150px;
                height: 150px;
                bottom: 20px;
                right: 20px;
            }
            
            #mobileControls {
                display: flex;
            }
            
            #controlsPanel {
                display: none;
            }
        }
        
        @media (max-width: 480px) {
            .player-info {
                flex-direction: column;
                gap: 10px;
            }
            
            .game-info {
                flex-direction: column;
                gap: 10px;
            }
            
            #minimapContainer {
                display: none;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div id="gameContainer">
        <div id="loadingScreen">
            <div class="loader"></div>
            <h2 style="margin-bottom: 10px; color: var(--primary);">HORIZON BROWSER</h2>
            <p style="color: var(--gray); margin-bottom: 20px;">Loading Mexico...</p>
            <div class="progress-bar">
                <div class="progress-fill" id="loadingProgress"></div>
            </div>
            <div id="loadingText" style="margin-top: 10px; color: var(--gray); font-size: 14px;"></div>
        </div>
        
        <div id="carSelection">
            <div class="selection-header">
                <h1 class="selection-title">CHOOSE YOUR HORIZON STARTER</h1>
                <p class="selection-subtitle">Select your vehicle and begin your Mexican adventure</p>
            </div>
            
            <div class="car-grid">
                <div class="car-card" data-car="street">
                    <div class="car-icon">üèéÔ∏è</div>
                    <h3 class="car-name">SPORTS COUPE</h3>
                    <div class="car-specs">
                        <div class="spec-item">
                            <div class="spec-value">180</div>
                            <div class="spec-label">Top Speed</div>
                        </div>
                        <div class="spec-item">
                            <div class="spec-value">4.2s</div>
                            <div class="spec-label">0-100 km/h</div>
                        </div>
                        <div class="spec-item">
                            <div class="spec-value">650 HP</div>
                            <div class="spec-label">Power</div>
                        </div>
                    </div>
                    <p class="car-description">Perfect balance of speed and control for road racing. Excellent handling on asphalt.</p>
                    <button class="select-button" onclick="selectCar('street')">SELECT</button>
                </div>
                
                <div class="car-card" data-car="offroad">
                    <div class="car-icon">üöô</div>
                    <h3 class="car-name">OFF-ROAD SUV</h3>
                    <div class="car-specs">
                        <div class="spec-item">
                            <div class="spec-value">140</div>
                            <div class="spec-label">Top Speed</div>
                        </div>
                        <div class="spec-item">
                            <div class="spec-value">5.8s</div>
                            <div class="spec-label">0-100 km/h</div>
                        </div>
                        <div class="spec-item">
                            <div class="spec-value">450 HP</div>
                            <div class="spec-label">Power</div>
                        </div>
                    </div>
                    <p class="car-description">Conquer any terrain. Advanced suspension and all-wheel drive for off-road mastery.</p>
                    <button class="select-button" onclick="selectCar('offroad')">SELECT</button>
                </div>
                
                <div class="car-card" data-car="hyper">
                    <div class="car-icon">‚ö°</div>
                    <h3 class="car-name">HYPER CAR</h3>
                    <div class="car-specs">
                        <div class="spec-item">
                            <div class="spec-value">220</div>
                            <div class="spec-label">Top Speed</div>
                        </div>
                        <div class="spec-item">
                            <div class="spec-value">2.9s</div>
                            <div class="spec-label">0-100 km/h</div>
                        </div>
                        <div class="spec-item">
                            <div class="spec-value">800 HP</div>
                            <div class="spec-label">Power</div>
                        </div>
                    </div>
                    <p class="car-description">Ultimate speed machine. Aerodynamic design and brutal acceleration for pure speed.</p>
                    <button class="select-button" onclick="selectCar('hyper')">SELECT</button>
                </div>
            </div>
            
            <div style="display: flex; gap: 15px; margin-top: 20px;">
                <div class="control-button" onclick="toggleDifficulty()">
                    <i class="fas fa-sliders-h"></i>
                    <span>DIFFICULTY: <span id="difficultyText">NORMAL</span></span>
                </div>
                <div class="control-button" onclick="toggleAssists()">
                    <i class="fas fa-car-crash"></i>
                    <span>ASSISTS: <span id="assistsText">ON</span></span>
                </div>
                <div class="control-button" onclick="startAITest()">
                    <i class="fas fa-robot"></i>
                    <span>AI TEST DRIVE</span>
                </div>
            </div>
        </div>
        
        <div id="gameUI">
            <!-- Top Bar -->
            <div id="topBar">
                <div class="player-info">
                    <div class="player-avatar">H</div>
                    <div class="player-stats">
                        <div class="stat-item">
                            <div class="stat-label">LEVEL</div>
                            <div class="stat-value" id="playerLevel">1</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">INFLUENCE</div>
                            <div class="stat-value" id="playerInfluence">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">CREDITS</div>
                            <div class="stat-value" id="playerCredits">50,000</div>
                        </div>
                    </div>
                </div>
                
                <div class="game-info">
                    <div class="info-card">
                        <div class="stat-label">TIME</div>
                        <div class="stat-value" id="gameTime">12:00</div>
                    </div>
                    <div class="info-card">
                        <div class="stat-label">WEATHER</div>
                        <div class="stat-value" id="gameWeather">SUNNY</div>
                    </div>
                    <div class="info-card">
                        <div class="stat-label">DAMAGE</div>
                        <div class="stat-value" id="carDamage">0%</div>
                    </div>
                </div>
            </div>
            
            <!-- Speedometer -->
            <div id="speedometer">
                <div class="speed-display">
                    <span class="speed-value" id="currentSpeed">0</span>
                    <span class="speed-unit">km/h</span>
                </div>
                <div class="gear-display" id="currentGear">N</div>
                <div class="rpm-bar">
                    <div class="rpm-fill" id="rpmFill"></div>
                </div>
            </div>
            
            <!-- Minimap -->
            <div id="minimapContainer">
                <div class="minimap-header">
                    <span>MAP</span>
                    <span id="currentLocation">GUANAJUATO</span>
                </div>
                <canvas id="minimapCanvas"></canvas>
            </div>
            
            <!-- Event Progress -->
            <div id="eventProgress">
                <div class="event-title" id="currentEvent">WELCOME TO MEXICO</div>
                <div class="event-description" id="eventDescription">Drive to the festival site to begin</div>
                <div class="progress-container">
                    <div class="progress-fill" id="eventProgressFill"></div>
                </div>
            </div>
            
            <!-- Bottom Controls -->
            <div id="controlsPanel">
                <div class="control-button" onclick="toggleCamera()">
                    <i class="fas fa-camera"></i>
                    <span>CAMERA</span>
                </div>
                <div class="control-button" onclick="toggleMap()">
                    <i class="fas fa-map"></i>
                    <span>MAP</span>
                </div>
                <div class="control-button" onclick="togglePhotoMode()">
                    <i class="fas fa-camera-retro"></i>
                    <span>PHOTO</span>
                </div>
                <div class="control-button" onclick="togglePause()">
                    <i class="fas fa-pause"></i>
                    <span>PAUSE</span>
                </div>
            </div>
            
            <!-- Mobile Controls -->
            <div id="mobileControls">
                <div class="mobile-control-group">
                    <div class="mobile-button" id="mobileBrake" ontouchstart="mobileKeyDown('s')" ontouchend="mobileKeyUp('s')">
                        <i class="fas fa-arrow-down"></i>
                    </div>
                    <div class="mobile-button" id="mobileHandbrake" ontouchstart="mobileKeyDown(' ')" ontouchend="mobileKeyUp(' ')">
                        <i class="fas fa-exclamation-circle"></i>
                    </div>
                </div>
                <div class="mobile-stick" id="mobileSteering" ontouchstart="startSteering(event)" ontouchmove="updateSteering(event)" ontouchend="resetSteering()">
                    <div class="stick-handle"></div>
                </div>
                <div class="mobile-control-group">
                    <div class="mobile-button" id="mobileCamera" ontouchstart="toggleCamera()">
                        <i class="fas fa-camera"></i>
                    </div>
                    <div class="mobile-button" id="mobilePause" ontouchstart="togglePause()">
                        <i class="fas fa-pause"></i>
                    </div>
                </div>
            </div>
            
            <!-- Notification Center -->
            <div id="notificationCenter"></div>
            
            <!-- Performance Stats -->
            <div id="performanceStats">
                <div class="stats-grid">
                    <div class="stat-row">
                        <span class="stat-name">FPS:</span>
                        <span class="stat-value" id="statFPS">60</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-name">Latency:</span>
                        <span class="stat-value" id="statLatency">16ms</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-name">Triangles:</span>
                        <span class="stat-value" id="statTriangles">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-name">Memory:</span>
                        <span class="stat-value" id="statMemory">0MB</span>
                    </div>
                </div>
            </div>
            
            <!-- Damage Indicator -->
            <div id="damageIndicator">
                <div class="damage-bar">
                    <div class="damage-fill" id="damageFill"></div>
                </div>
            </div>
        </div>
        
        <!-- Pause Menu -->
        <div id="pauseMenu">
            <h2 class="pause-title">PAUSED</h2>
            <div class="menu-options">
                <div class="menu-option" onclick="togglePause()">RESUME</div>
                <div class="menu-option" onclick="restartEvent()">RESTART EVENT</div>
                <div class="menu-option" onclick="changeCar()">CHANGE CAR</div>
                <div class="menu-option" onclick="togglePerformanceStats()">
                    <i class="fas fa-chart-line"></i>
                    TOGGLE STATS
                </div>
                <div class="menu-option" onclick="showSettings()">
                    <i class="fas fa-cog"></i>
                    SETTINGS
                </div>
                <div class="menu-option" onclick="quitToMenu()">
                    <i class="fas fa-sign-out-alt"></i>
                    QUIT TO MENU
                </div>
            </div>
        </div>
        
        <!-- Achievement Popup -->
        <div id="achievementPopup">
            <div class="achievement-icon">üèÜ</div>
            <div class="achievement-title" id="achievementTitle">ACHIEVEMENT UNLOCKED</div>
            <div class="achievement-desc" id="achievementDesc">Complete the tutorial</div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';

        // ============================
        // GAME STATE & CONFIGURATION
        // ============================
        const GameConfig = {
            // Graphics
            graphics: {
                quality: 'high', // low, medium, high, ultra
                shadows: true,
                antialiasing: true,
                bloom: true,
                motionBlur: true,
                maxFPS: 60,
                resolutionScale: 1.0
            },
            
            // Physics
            physics: {
                timestep: 1/60,
                subSteps: 3,
                gravity: 9.81,
                solverIterations: 10
            },
            
            // Gameplay
            gameplay: {
                difficulty: 'normal', // easy, normal, hard, expert
                assists: {
                    tractionControl: true,
                    stabilityControl: true,
                    abs: true,
                    steeringAssist: true,
                    brakingAssist: false,
                    damage: 'cosmetic' // none, cosmetic, simulation
                },
                rewards: {
                    baseXP: 100,
                    winMultiplier: 2.0,
                    discoveryBonus: 50,
                    skillChainBonus: 1.5
                }
            },
            
            // Audio
            audio: {
                masterVolume: 0.8,
                musicVolume: 0.6,
                sfxVolume: 0.7,
                engineVolume: 0.8,
                ambientVolume: 0.5,
                dynamicRange: 'high'
            }
        };

        let gameState = {
            // Player
            player: {
                level: 1,
                xp: 0,
                xpToNextLevel: 1000,
                influence: 0,
                credits: 50000,
                skillChain: 0,
                maxSkillChain: 0,
                playTime: 0,
                distanceTraveled: 0
            },
            
            // Car
            car: {
                type: null,
                health: 100,
                fuel: 100,
                dirtLevel: 0,
                temperature: {
                    engine: 90,
                    tires: 80,
                    brakes: 100
                },
                wear: {
                    engine: 0,
                    tires: 0,
                    brakes: 0,
                    suspension: 0
                }
            },
            
            // Game World
            world: {
                time: 12.0, // 0-24
                weather: 'sunny',
                weatherIntensity: 0,
                temperature: 25, // Celsius
                wind: {
                    speed: 0,
                    direction: 0
                },
                trafficDensity: 0.3
            },
            
            // Events
            currentEvent: {
                type: 'exploration',
                name: 'Welcome to Mexico',
                description: 'Discover the festival site',
                progress: 0,
                total: 100,
                rewards: {
                    xp: 500,
                    influence: 100,
                    credits: 10000
                }
            },
            
            // AI
            ai: {
                enabled: false,
                mode: 'explore', // explore, race, chase, follow
                target: null,
                aggression: 0.5,
                skill: 0.7
            },
            
            // UI State
            ui: {
                cameraMode: 'chase', // chase, bumper, hood, cockpit, orbit
                mapVisible: true,
                performanceStats: false,
                photoMode: false,
                paused: false,
                notifications: []
            },
            
            // Input
            input: {
                keys: {},
                steering: 0,
                throttle: 0,
                brake: 0,
                handbrake: 0,
                isMobile: false,
                touchSteering: 0
            },
            
            // Performance
            performance: {
                fps: 60,
                frameTime: 16,
                drawCalls: 0,
                triangles: 0,
                memory: 0,
                loadingProgress: 0
            }
        };

        // ============================
        // GAME SYSTEMS INITIALIZATION
        // ============================
        
        // Three.js Core
        let scene, camera, renderer, composer, controls;
        
        // Systems
        let physicsEngine, terrainSystem, weatherSystem, audioSystem;
        let damageSystem, cameraSystem, uiSystem, eventSystem;
        let aiSystem, trafficSystem, economySystem;
        
        // Game Objects
        let playerCar = null;
        let terrain = null;
        let environment = null;
        let aiCars = [];
        let trafficCars = [];
        
        // Post-processing
        let bloomPass, filmPass;
        
        // Loader
        const loader = new GLTFLoader();
        const textureLoader = new THREE.TextureLoader();
        
        // Assets
        const assets = {
            textures: {},
            models: {},
            sounds: {}
        };
        
        // ============================
        // PHYSICS ENGINE
        // ============================
        class PhysicsEngine {
            constructor() {
                this.timeScale = 1.0;
                this.fixedTimestep = 1/60;
                this.accumulator = 0;
                this.gravity = new THREE.Vector3(0, -9.81, 0);
                
                this.collisionWorld = new Map();
                this.rigidBodies = [];
            }
            
            addRigidBody(body) {
                this.rigidBodies.push(body);
            }
            
            update(deltaTime, car, inputs) {
                const scaledDelta = deltaTime * this.timeScale;
                this.accumulator += scaledDelta;
                
                while (this.accumulator >= this.fixedTimestep) {
                    this.fixedUpdate(car, inputs);
                    this.accumulator -= this.fixedTimestep;
                }
                
                // Interpolate
                const alpha = this.accumulator / this.fixedTimestep;
                if (car) {
                    car.interpolate(alpha);
                }
            }
            
            fixedUpdate(car, inputs) {
                if (!car) return;
                
                // Calculate forces
                const forces = this.calculateForces(car, inputs);
                
                // Apply forces
                this.applyForces(car, forces);
                
                // Check collisions
                this.checkCollisions(car);
                
                // Update car state
                car.updatePhysics(this.fixedTimestep);
            }
            
            calculateForces(car, inputs) {
                const forces = {
                    engine: new THREE.Vector3(),
                    braking: new THREE.Vector3(),
                    steering: new THREE.Vector3(),
                    drag: new THREE.Vector3(),
                    rolling: new THREE.Vector3(),
                    downforce: new THREE.Vector3(),
                    suspension: new THREE.Vector3()
                };
                
                // Engine force
                const engineForce = car.calculateEngineForce(inputs.throttle);
                forces.engine = car.getForwardVector().multiplyScalar(engineForce);
                
                // Braking force
                const brakeForce = car.calculateBrakeForce(inputs.brake);
                forces.braking = car.getVelocity().clone().normalize().multiplyScalar(-brakeForce);
                
                // Drag force (aerodynamic)
                const dragForce = car.calculateDragForce();
                forces.drag = car.getVelocity().clone().normalize().multiplyScalar(-dragForce);
                
                // Rolling resistance
                const rollingForce = car.calculateRollingResistance();
                forces.rolling = car.getVelocity().clone().normalize().multiplyScalar(-rollingForce);
                
                // Downforce
                const downforce = car.calculateDownforce();
                forces.downforce = new THREE.Vector3(0, -downforce, 0);
                
                // Suspension forces
                forces.suspension = car.calculateSuspensionForces();
                
                return forces;
            }
            
            applyForces(car, forces) {
                const totalForce = new THREE.Vector3();
                Object.values(forces).forEach(force => totalForce.add(force));
                
                // Apply gravity
                totalForce.add(this.gravity.clone().multiplyScalar(car.mass));
                
                // Calculate acceleration
                const acceleration = totalForce.divideScalar(car.mass);
                
                // Update velocity
                car.velocity.add(acceleration.clone().multiplyScalar(this.fixedTimestep));
                
                // Apply steering
                const turnRate = car.calculateTurnRate(gameState.input.steering);
                car.angularVelocity.y = turnRate;
            }
            
            checkCollisions(car) {
                // Simplified collision detection
                for (const body of this.rigidBodies) {
                    if (body === car) continue;
                    
                    const distance = car.position.distanceTo(body.position);
                    const minDistance = car.boundingRadius + body.boundingRadius;
                    
                    if (distance < minDistance) {
                        this.resolveCollision(car, body);
                    }
                }
            }
            
            resolveCollision(car, other) {
                // Collision response
                const normal = car.position.clone().sub(other.position).normalize();
                const relativeVelocity = car.velocity.clone().sub(other.velocity);
                const velocityAlongNormal = relativeVelocity.dot(normal);
                
                if (velocityAlongNormal > 0) return;
                
                const restitution = 0.3;
                let j = -(1 + restitution) * velocityAlongNormal;
                j /= 1/car.mass + 1/other.mass;
                
                const impulse = normal.multiplyScalar(j);
                car.velocity.add(impulse.clone().divideScalar(car.mass));
                
                // Apply damage
                if (damageSystem) {
                    const impactForce = impulse.length();
                    damageSystem.applyDamage(impactForce, 'collision', car.position);
                }
            }
        }

        // ============================
        // CAR PHYSICS MODEL
        // ============================
        class CarPhysicsModel {
            constructor(type) {
                this.type = type;
                this.setupParameters();
                this.reset();
            }
            
            setupParameters() {
                // Realistic car parameters based on type
                const params = {
                    street: {
                        mass: 1500,
                        wheelBase: 2.7,
                        trackWidth: 1.8,
                        centerOfMassHeight: 0.5,
                        momentOfInertia: 1500,
                        
                        engine: {
                            maxTorque: 650,
                            maxPower: 485,
                            maxRPM: 7000,
                            idleRPM: 800,
                            redlineRPM: 6800,
                            torqueCurve: this.createTorqueCurve([0.3, 0.6, 0.9, 1.0, 0.95, 0.85])
                        },
                        
                        transmission: {
                            gears: 7,
                            finalDrive: 3.2,
                            gearRatios: [3.82, 2.26, 1.64, 1.28, 1.05, 0.86, 0.72],
                            shiftTime: 0.2
                        },
                        
                        tires: {
                            frontGrip: 1.1,
                            rearGrip: 1.05,
                            rollingResistance: 0.015,
                            slipAnglePeak: 8
                        },
                        
                        suspension: {
                            stiffness: 35000,
                            damping: 5000,
                            travel: 0.15
                        },
                        
                        aerodynamics: {
                            dragCoefficient: 0.32,
                            frontalArea: 2.2,
                            downforceCoefficient: 0.3
                        }
                    },
                    
                    offroad: {
                        mass: 2200,
                        wheelBase: 3.0,
                        trackWidth: 1.85,
                        centerOfMassHeight: 0.8,
                        momentOfInertia: 2500,
                        
                        engine: {
                            maxTorque: 450,
                            maxPower: 335,
                            maxRPM: 6000,
                            idleRPM: 700,
                            redlineRPM: 5800,
                            torqueCurve: this.createTorqueCurve([0.4, 0.8, 1.0, 0.9, 0.75, 0.6])
                        },
                        
                        transmission: {
                            gears: 6,
                            finalDrive: 4.1,
                            gearRatios: [4.28, 2.62, 1.80, 1.39, 1.00, 0.82],
                            shiftTime: 0.3
                        },
                        
                        tires: {
                            frontGrip: 0.85,
                            rearGrip: 0.85,
                            rollingResistance: 0.025,
                            slipAnglePeak: 12
                        },
                        
                        suspension: {
                            stiffness: 20000,
                            damping: 3000,
                            travel: 0.25
                        },
                        
                        aerodynamics: {
                            dragCoefficient: 0.45,
                            frontalArea: 3.0,
                            downforceCoefficient: 0.1
                        }
                    },
                    
                    hyper: {
                        mass: 1400,
                        wheelBase: 2.65,
                        trackWidth: 1.95,
                        centerOfMassHeight: 0.4,
                        momentOfInertia: 1200,
                        
                        engine: {
                            maxTorque: 800,
                            maxPower: 785,
                            maxRPM: 8500,
                            idleRPM: 900,
                            redlineRPM: 8200,
                            torqueCurve: this.createTorqueCurve([0.2, 0.5, 0.8, 1.0, 0.95, 0.8])
                        },
                        
                        transmission: {
                            gears: 8,
                            finalDrive: 3.0,
                            gearRatios: [3.91, 2.72, 2.10, 1.72, 1.42, 1.21, 1.05, 0.91],
                            shiftTime: 0.15
                        },
                        
                        tires: {
                            frontGrip: 1.3,
                            rearGrip: 1.25,
                            rollingResistance: 0.012,
                            slipAnglePeak: 6
                        },
                        
                        suspension: {
                            stiffness: 45000,
                            damping: 6000,
                            travel: 0.12
                        },
                        
                        aerodynamics: {
                            dragCoefficient: 0.28,
                            frontalArea: 2.0,
                            downforceCoefficient: 0.5
                        }
                    }
                };
                
                this.params = params[this.type];
                this.currentGear = 0; // 0 = neutral, -1 = reverse
                this.rpm = this.params.engine.idleRPM;
                this.throttle = 0;
                this.brake = 0;
                this.steering = 0;
                
                // State variables
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.angularVelocity = new THREE.Vector3(0, 0, 0);
                this.position = new THREE.Vector3(0, 0, 0);
                this.rotation = new THREE.Quaternion();
                this.previousPosition = new THREE.Vector3(0, 0, 0);
                this.previousRotation = new THREE.Quaternion();
                
                // Wheel states
                this.wheels = [
                    { // Front left
                        position: new THREE.Vector3(-this.params.trackWidth/2, 0, this.params.wheelBase/2),
                        steering: 0,
                        angularVelocity: 0,
                        slipRatio: 0,
                        slipAngle: 0,
                        load: 0,
                        contact: false,
                        contactPoint: new THREE.Vector3(),
                        contactNormal: new THREE.Vector3(0, 1, 0)
                    },
                    { // Front right
                        position: new THREE.Vector3(this.params.trackWidth/2, 0, this.params.wheelBase/2),
                        steering: 0,
                        angularVelocity: 0,
                        slipRatio: 0,
                        slipAngle: 0,
                        load: 0,
                        contact: false,
                        contactPoint: new THREE.Vector3(),
                        contactNormal: new THREE.Vector3(0, 1, 0)
                    },
                    { // Rear left
                        position: new THREE.Vector3(-this.params.trackWidth/2, 0, -this.params.wheelBase/2),
                        steering: 0,
                        angularVelocity: 0,
                        slipRatio: 0,
                        slipAngle: 0,
                        load: 0,
                        contact: false,
                        contactPoint: new THREE.Vector3(),
                        contactNormal: new THREE.Vector3(0, 1, 0)
                    },
                    { // Rear right
                        position: new THREE.Vector3(this.params.trackWidth/2, 0, -this.params.wheelBase/2),
                        steering: 0,
                        angularVelocity: 0,
                        slipRatio: 0,
                        slipAngle: 0,
                        load: 0,
                        contact: false,
                        contactPoint: new THREE.Vector3(),
                        contactNormal: new THREE.Vector3(0, 1, 0)
                    }
                ];
                
                // Bounding sphere for collision
                this.boundingRadius = Math.sqrt(
                    Math.pow(this.params.wheelBase/2, 2) + 
                    Math.pow(this.params.trackWidth/2, 2)
                );
            }
            
            createTorqueCurve(points) {
                return (rpm) => {
                    const normalized = rpm / this.params.engine.maxRPM;
                    const index = normalized * (points.length - 1);
                    const floor = Math.floor(index);
                    const fraction = index - floor;
                    
                    if (floor >= points.length - 1) {
                        return points[points.length - 1] * this.params.engine.maxTorque;
                    }
                    
                    const value = THREE.MathUtils.lerp(
                        points[floor], 
                        points[floor + 1], 
                        fraction
                    );
                    
                    return value * this.params.engine.maxTorque;
                };
            }
            
            reset() {
                this.velocity.set(0, 0, 0);
                this.angularVelocity.set(0, 0, 0);
                this.rpm = this.params.engine.idleRPM;
                this.currentGear = 0;
                this.throttle = 0;
                this.brake = 0;
                this.steering = 0;
            }
            
            getForwardVector() {
                const forward = new THREE.Vector3(0, 0, 1);
                forward.applyQuaternion(this.rotation);
                return forward;
            }
            
            getVelocity() {
                return this.velocity;
            }
            
            calculateEngineForce(throttleInput) {
                this.throttle = throttleInput;
                
                // Update RPM based on wheel speed
                this.updateRPM();
                
                // Calculate torque from engine
                const torqueCurve = this.params.engine.torqueCurve;
                const engineTorque = torqueCurve(this.rpm) * this.throttle;
                
                // Apply gear ratio
                if (this.currentGear !== 0) {
                    const gearRatio = this.currentGear > 0 ? 
                        this.params.transmission.gearRatios[this.currentGear - 1] : 
                        this.params.transmission.gearRatios[0] * -1; // Reverse
                    
                    const wheelTorque = engineTorque * gearRatio * this.params.transmission.finalDrive;
                    
                    // Convert to force at wheels
                    const wheelRadius = 0.35; // meters
                    return wheelTorque / wheelRadius;
                }
                
                return 0;
            }
            
            updateRPM() {
                if (this.currentGear === 0) { // Neutral
                    this.rpm = THREE.MathUtils.lerp(
                        this.rpm,
                        this.params.engine.idleRPM + 1000 * this.throttle,
                        0.1
                    );
                } else {
                    // Calculate wheel RPM
                    const wheelRadius = 0.35;
                    const wheelSpeed = this.velocity.length();
                    const wheelRPM = wheelSpeed * 60 / (2 * Math.PI * wheelRadius);
                    
                    // Calculate engine RPM from gear ratio
                    const gearRatio = this.currentGear > 0 ? 
                        this.params.transmission.gearRatios[this.currentGear - 1] : 
                        this.params.transmission.gearRatios[0];
                    
                    const drivetrainRatio = gearRatio * this.params.transmission.finalDrive;
                    const targetRPM = Math.abs(wheelRPM * drivetrainRatio);
                    
                    // Auto-shift logic
                    if (this.currentGear > 0) {
                        if (this.rpm > this.params.engine.redlineRPM && this.throttle > 0.3) {
                            if (this.currentGear < this.params.transmission.gears) {
                                this.shiftUp();
                            }
                        } else if (this.rpm < this.params.engine.idleRPM * 2 && this.currentGear > 1) {
                            this.shiftDown();
                        }
                    }
                    
                    // Smooth RPM transition
                    this.rpm = THREE.MathUtils.lerp(this.rpm, targetRPM, 0.2);
                }
                
                // Clamp RPM
                this.rpm = THREE.MathUtils.clamp(
                    this.rpm,
                    this.params.engine.idleRPM,
                    this.params.engine.maxRPM
                );
            }
            
            shiftUp() {
                if (this.currentGear < this.params.transmission.gears) {
                    this.currentGear++;
                    this.rpm *= 0.7; // Simulate shift
                    return true;
                }
                return false;
            }
            
            shiftDown() {
                if (this.currentGear > 1) {
                    this.currentGear--;
                    this.rpm *= 1.3; // Simulate shift
                    return true;
                }
                return false;
            }
            
            calculateBrakeForce(brakeInput) {
                this.brake = brakeInput;
                const maxBrakeForce = 10000; // Newtons
                return maxBrakeForce * this.brake;
            }
            
            calculateDragForce() {
                const airDensity = 1.225; // kg/m¬≥
                const speed = this.velocity.length();
                return 0.5 * airDensity * 
                       speed * speed * 
                       this.params.aerodynamics.dragCoefficient * 
                       this.params.aerodynamics.frontalArea;
            }
            
            calculateRollingResistance() {
                const normalForce = this.mass * 9.81;
                return normalForce * this.params.tires.rollingResistance;
            }
            
            calculateDownforce() {
                const speed = this.velocity.length();
                return 0.5 * 1.225 * 
                       speed * speed * 
                       this.params.aerodynamics.downforceCoefficient * 
                       this.params.aerodynamics.frontalArea;
            }
            
            calculateSuspensionForces() {
                // Simplified suspension calculation
                const force = new THREE.Vector3(0, 0, 0);
                
                this.wheels.forEach(wheel => {
                    if (wheel.contact) {
                        const compression = 0.1; // Simplified
                        const springForce = compression * this.params.suspension.stiffness;
                        const dampingForce = 0; // Would need velocity
                        wheel.load = springForce + dampingForce;
                        force.y += wheel.load;
                    }
                });
                
                return force;
            }
            
            calculateTurnRate(steeringInput) {
                this.steering = THREE.MathUtils.clamp(steeringInput, -1, 1);
                
                if (Math.abs(this.velocity.length()) < 0.1) return 0;
                
                // Calculate turn radius based on steering angle
                const maxSteering = 0.7; // radians (~40 degrees)
                const steeringAngle = this.steering * maxSteering;
                
                // Ackermann steering geometry
                const turnRadius = this.params.wheelBase / Math.tan(steeringAngle);
                
                if (Math.abs(turnRadius) < 0.1) return 0;
                
                // Angular velocity
                return this.velocity.length() / turnRadius;
            }
            
            updatePhysics(deltaTime) {
                // Save previous state for interpolation
                this.previousPosition.copy(this.position);
                this.previousRotation.copy(this.rotation);
                
                // Update position
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // Update rotation
                const rotationDelta = new THREE.Quaternion().setFromEuler(
                    new THREE.Euler(
                        0,
                        this.angularVelocity.y * deltaTime,
                        0
                    )
                );
                this.rotation.multiply(rotationDelta);
                
                // Update wheel positions
                this.updateWheelTransforms();
                
                // Update slip angles
                this.updateSlipAngles();
            }
            
            updateWheelTransforms() {
                this.wheels.forEach(wheel => {
                    // Transform wheel position to world space
                    const worldPosition = wheel.position.clone();
                    worldPosition.applyQuaternion(this.rotation);
                    worldPosition.add(this.position);
                    wheel.contactPoint.copy(worldPosition);
                    
                    // Check ground contact (simplified)
                    const terrainHeight = terrainSystem ? 
                        terrainSystem.getHeight(worldPosition.x, worldPosition.z) : 0;
                    
                    wheel.contact = worldPosition.y <= terrainHeight + 0.5;
                    
                    if (wheel.contact) {
                        wheel.contactPoint.y = terrainHeight;
                        wheel.contactNormal.set(0, 1, 0);
                    }
                });
            }
            
            updateSlipAngles() {
                const forward = this.getForwardVector();
                const lateral = new THREE.Vector3(-forward.z, 0, forward.x);
                
                this.wheels.forEach(wheel => {
                    if (!wheel.contact) {
                        wheel.slipAngle = 0;
                        wheel.slipRatio = 0;
                        return;
                    }
                    
                    // Calculate wheel velocity in world space
                    const wheelVelocity = this.velocity.clone();
                    
                    // Add rotational velocity
                    const angularVelocityAtWheel = new THREE.Vector3();
                    angularVelocityAtWheel.crossVectors(
                        this.angularVelocity,
                        wheel.position.clone().applyQuaternion(this.rotation)
                    );
                    wheelVelocity.add(angularVelocityAtWheel);
                    
                    // Decompose into longitudinal and lateral components
                    const longitudinalSpeed = wheelVelocity.dot(forward);
                    const lateralSpeed = wheelVelocity.dot(lateral);
                    
                    // Calculate slip angle
                    if (Math.abs(longitudinalSpeed) > 0.1) {
                        wheel.slipAngle = Math.atan2(lateralSpeed, Math.abs(longitudinalSpeed));
                    } else {
                        wheel.slipAngle = 0;
                    }
                    
                    // Calculate slip ratio
                    const wheelRadius = 0.35;
                    const wheelAngularSpeed = wheel.angularVelocity;
                    const theoreticalSpeed = wheelAngularSpeed * wheelRadius;
                    
                    if (Math.abs(theoreticalSpeed) > 0.1) {
                        wheel.slipRatio = (theoreticalSpeed - longitudinalSpeed) / Math.abs(theoreticalSpeed);
                    } else {
                        wheel.slipRatio = 0;
                    }
                });
            }
            
            interpolate(alpha) {
                // Linear interpolation for smooth rendering
                this.position.lerpVectors(this.previousPosition, this.position, alpha);
                
                // Slerp for rotation
                this.rotation.slerp(this.previousRotation, this.rotation, alpha);
            }
            
            get mass() { return this.params.mass; }
        }

        // ============================
        // TERRAIN SYSTEM
        // ============================
        class TerrainSystem {
            constructor() {
                this.size = 2000;
                this.resolution = 512;
                this.heightScale = 100;
                this.heightData = null;
                this.normalData = null;
                this.typeData = null;
                
                this.generateHeightmap();
                this.calculateNormals();
            }
            
            generateHeightmap() {
                const size = this.resolution;
                this.heightData = new Float32Array(size * size);
                this.typeData = new Uint8Array(size * size);
                
                // Generate multiple layers of noise
                for (let z = 0; z < size; z++) {
                    for (let x = 0; x < size; x++) {
                        let height = 0;
                        
                        // Base terrain with Perlin-like noise
                        const nx = x / size * 8;
                        const nz = z / size * 8;
                        
                        // Multiple octaves for realistic terrain
                        height += this.noise(nx, nz) * 0.5;
                        height += this.noise(nx * 2, nz * 2) * 0.25;
                        height += this.noise(nx * 4, nz * 4) * 0.125;
                        height += this.noise(nx * 8, nz * 8) * 0.0625;
                        
                        // Mountains in the distance
                        const distFromCenter = Math.sqrt(
                            Math.pow(x/size - 0.5, 2) + 
                            Math.pow(z/size - 0.5, 2)
                        );
                        
                        if (distFromCenter > 0.3) {
                            height += Math.sin(distFromCenter * 20) * 0.2;
                        }
                        
                        // City area (flat)
                        const cityX = 0.6;
                        const cityZ = 0.6;
                        const cityDist = Math.sqrt(
                            Math.pow(x/size - cityX, 2) + 
                            Math.pow(z/size - cityZ, 2)
                        );
                        
                        if (cityDist < 0.1) {
                            height *= 0.1; // Flatten city area
                        }
                        
                        this.heightData[z * size + x] = height * this.heightScale;
                        
                        // Determine terrain type
                        let type = 0; // Grass
                        if (height > 0.3) type = 1; // Rock
                        else if (cityDist < 0.1) type = 2; // Asphalt
                        else if (height < -0.1) type = 3; // Water
                        else if (Math.abs(x/size - 0.5) < 0.05 || Math.abs(z/size - 0.5) < 0.05) {
                            type = 2; // Roads
                        }
                        
                        this.typeData[z * size + x] = type;
                    }
                }
            }
            
            noise(x, z) {
                // Simple pseudo-random noise
                return Math.sin(x * 12.9898 + z * 78.233) * 43758.5453 % 1;
            }
            
            calculateNormals() {
                const size = this.resolution;
                this.normalData = new Float32Array(size * size * 3);
                
                for (let z = 0; z < size; z++) {
                    for (let x = 0; x < size; x++) {
                        const idx = (z * size + x) * 3;
                        
                        // Get neighboring heights
                        const left = this.getHeight(x-1, z);
                        const right = this.getHeight(x+1, z);
                        const up = this.getHeight(x, z-1);
                        const down = this.getHeight(x, z+1);
                        
                        // Calculate normal using Sobel filter
                        const dx = (right - left) / (2 * (this.size / size));
                        const dz = (down - up) / (2 * (this.size / size));
                        
                        this.normalData[idx] = -dx;
                        this.normalData[idx + 1] = 1;
                        this.normalData[idx + 2] = -dz;
                        
                        // Normalize
                        const length = Math.sqrt(
                            dx*dx + 1 + dz*dz
                        );
                        
                        this.normalData[idx] /= length;
                        this.normalData[idx + 1] /= length;
                        this.normalData[idx + 2] /= length;
                    }
                }
            }
            
            getHeight(x, z) {
                const gridX = Math.floor((x + this.size/2) / this.size * this.resolution);
                const gridZ = Math.floor((z + this.size/2) / this.size * this.resolution);
                
                if (gridX < 0 || gridX >= this.resolution || 
                    gridZ < 0 || gridZ >= this.resolution) {
                    return 0;
                }
                
                return this.heightData[gridZ * this.resolution + gridX];
            }
            
            getNormal(x, z) {
                const gridX = Math.floor((x + this.size/2) / this.size * this.resolution);
                const gridZ = Math.floor((z + this.size/2) / this.size * this.resolution);
                
                if (gridX < 0 || gridX >= this.resolution || 
                    gridZ < 0 || gridZ >= this.resolution) {
                    return new THREE.Vector3(0, 1, 0);
                }
                
                const idx = (gridZ * this.resolution + gridX) * 3;
                return new THREE.Vector3(
                    this.normalData[idx],
                    this.normalData[idx + 1],
                    this.normalData[idx + 2]
                );
            }
            
            getTerrainType(x, z) {
                const gridX = Math.floor((x + this.size/2) / this.size * this.resolution);
                const gridZ = Math.floor((z + this.size/2) / this.size * this.resolution);
                
                if (gridX < 0 || gridX >= this.resolution || 
                    gridZ < 0 || gridZ >= this.resolution) {
                    return 0;
                }
                
                return this.typeData[gridZ * this.resolution + gridX];
            }
            
            getFriction(type) {
                const frictions = [0.7, 0.6, 0.9, 0.3]; // Grass, Rock, Asphalt, Water
                return frictions[type] || 0.7;
            }
        }

        // ============================
        // WEATHER SYSTEM
        // ============================
        class WeatherSystem {
            constructor() {
                this.current = 'sunny';
                this.transition = 0;
                this.target = 'sunny';
                this.intensity = 0;
                this.wind = new THREE.Vector3(1, 0, 0);
                this.precipitation = 0;
                this.cloudCover = 0;
                
                this.particles = null;
                this.lightning = null;
                this.puddles = [];
                
                this.setupVisuals();
            }
            
            setupVisuals() {
                // Rain particles
                const rainCount = 2000;
                const positions = new Float32Array(rainCount * 3);
                const sizes = new Float32Array(rainCount);
                
                for (let i = 0; i < rainCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 200;
                    positions[i + 1] = Math.random() * 100 + 50;
                    positions[i + 2] = (Math.random() - 0.5) * 200;
                    sizes[i/3] = Math.random() * 0.5 + 0.3;
                }
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    color: 0xaaaaaa,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.particles.visible = false;
                scene.add(this.particles);
                
                // Lightning effect
                const lightningGeometry = new THREE.BufferGeometry();
                const lightningMaterial = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0
                });
                
                this.lightning = new THREE.Line(lightningGeometry, lightningMaterial);
                scene.add(this.lightning);
            }
            
            update(deltaTime) {
                // Update transition
                if (this.transition < 1) {
                    this.transition += deltaTime * 0.1;
                    this.updateWeatherProperties();
                }
                
                // Update particles
                if (this.current === 'rainy' || this.current === 'stormy') {
                    this.updateRainParticles(deltaTime);
                }
                
                // Random weather changes
                if (Math.random() < 0.001) {
                    this.changeWeather(this.getRandomWeather());
                }
            }
            
            updateWeatherProperties() {
                const weathers = {
                    sunny: { precipitation: 0, cloudCover: 0.1, wind: 0.2, fog: 0 },
                    cloudy: { precipitation: 0, cloudCover: 0.7, wind: 0.5, fog: 0.1 },
                    rainy: { precipitation: 0.8, cloudCover: 0.9, wind: 0.8, fog: 0.3 },
                    stormy: { precipitation: 1.0, cloudCover: 1.0, wind: 1.0, fog: 0.5 }
                };
                
                const from = weathers[this.current];
                const to = weathers[this.target];
                const t = this.transition;
                
                this.precipitation = THREE.MathUtils.lerp(from.precipitation, to.precipitation, t);
                this.cloudCover = THREE.MathUtils.lerp(from.cloudCover, to.cloudCover, t);
                this.intensity = THREE.MathUtils.lerp(from.wind, to.wind, t);
                
                // Update scene fog
                scene.fog.density = THREE.MathUtils.lerp(from.fog, to.fog, t) * 0.001;
                
                // Update particle visibility
                this.particles.visible = this.precipitation > 0.3;
                this.particles.material.opacity = this.precipitation * 0.6;
                
                if (t >= 1) {
                    this.current = this.target;
                }
            }
            
            updateRainParticles(deltaTime) {
                const positions = this.particles.geometry.attributes.position.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] -= 20 * deltaTime * (1 + this.intensity);
                    
                    // Wind effect
                    positions[i] += this.wind.x * this.intensity * 5 * deltaTime;
                    positions[i + 2] += this.wind.z * this.intensity * 5 * deltaTime;
                    
                    // Reset particles that fall below ground
                    if (positions[i + 1] < 0) {
                        positions[i] = (Math.random() - 0.5) * 200;
                        positions[i + 1] = Math.random() * 100 + 50;
                        positions[i + 2] = (Math.random() - 0.5) * 200;
                    }
                }
                
                this.particles.geometry.attributes.position.needsUpdate = true;
                
                // Random lightning in storms
                if (this.current === 'stormy' && Math.random() < 0.01) {
                    this.createLightning();
                }
            }
            
            createLightning() {
                // Create a lightning bolt
                const points = [];
                const start = new THREE.Vector3(
                    (Math.random() - 0.5) * 100,
                    100,
                    (Math.random() - 0.5) * 100
                );
                
                let current = start.clone();
                for (let i = 0; i < 10; i++) {
                    points.push(current.clone());
                    current.y -= 10 + Math.random() * 5;
                    current.x += (Math.random() - 0.5) * 3;
                    current.z += (Math.random() - 0.5) * 3;
                }
                
                this.lightning.geometry.setFromPoints(points);
                this.lightning.material.opacity = 1;
                
                // Fade out
                setTimeout(() => {
                    this.lightning.material.opacity = 0;
                }, 100);
            }
            
            changeWeather(weather) {
                this.target = weather;
                this.transition = 0;
                
                // Show notification
                showNotification(`Weather changing to ${weather.toUpperCase()}`);
            }
            
            getRandomWeather() {
                const weathers = ['sunny', 'cloudy', 'rainy', 'stormy'];
                return weathers[Math.floor(Math.random() * weathers.length)];
            }
            
            getFrictionMultiplier() {
                // Reduce friction when wet
                return Math.max(0.5, 1 - this.precipitation * 0.5);
            }
        }

        // ============================
        // AUDIO SYSTEM
        // ============================
        class AudioSystem {
            constructor() {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                this.sources = new Map();
                this.volumes = {
                    master: 0.8,
                    music: 0.6,
                    sfx: 0.7,
                    engine: 0.8,
                    ambient: 0.5
                };
                
                this.engineSound = null;
                this.tireSound = null;
                this.ambientSound = null;
                this.music = null;
                
                this.setupEngineSound();
                this.setupAmbientSound();
            }
            
            setupEngineSound() {
                // Create engine sound using Web Audio API
                this.engineSound = {
                    oscillator: this.context.createOscillator(),
                    gain: this.context.createGain(),
                    filter: this.context.createBiquadFilter()
                };
                
                this.engineSound.oscillator.connect(this.engineSound.filter);
                this.engineSound.filter.connect(this.engineSound.gain);
                this.engineSound.gain.connect(this.context.destination);
                
                this.engineSound.oscillator.type = 'sawtooth';
                this.engineSound.filter.type = 'lowpass';
                this.engineSound.gain.gain.value = 0;
                
                this.engineSound.oscillator.start();
            }
            
            setupAmbientSound() {
                // Create ambient wind/weather sounds
                this.ambientSound = {
                    noise: this.context.createBufferSource(),
                    gain: this.context.createGain(),
                    filter: this.context.createBiquadFilter()
                };
                
                // Create brown noise buffer
                const bufferSize = this.context.sampleRate * 2;
                const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const data = buffer.getChannelData(0);
                
                let lastOut = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    lastOut = (lastOut + white) * 0.98;
                    data[i] = lastOut * 0.1;
                }
                
                this.ambientSound.noise.buffer = buffer;
                this.ambientSound.noise.loop = true;
                this.ambientSound.noise.connect(this.ambientSound.filter);
                this.ambientSound.filter.connect(this.ambientSound.gain);
                this.ambientSound.gain.connect(this.context.destination);
                
                this.ambientSound.filter.type = 'lowpass';
                this.ambientSound.filter.frequency.value = 500;
                this.ambientSound.gain.gain.value = this.volumes.ambient;
                
                this.ambientSound.noise.start();
            }
            
            updateEngineSound(rpm, maxRPM, throttle, gear, speed) {
                if (!this.engineSound) return;
                
                // Calculate frequency based on RPM
                const baseFreq = 50;
                const freqMultiplier = rpm / 1000;
                const frequency = baseFreq * freqMultiplier;
                
                // Add gear harmonics
                const harmonic = gear > 0 ? gear * 0.15 : 0.3;
                
                // Update oscillator
                this.engineSound.oscillator.frequency.setValueAtTime(
                    frequency * (1 + harmonic),
                    this.context.currentTime
                );
                
                // Update filter based on throttle
                this.engineSound.filter.frequency.setValueAtTime(
                    200 + throttle * 1000,
                    this.context.currentTime
                );
                
                // Update volume
                const volume = throttle * 0.1 + 0.05;
                this.engineSound.gain.gain.setValueAtTime(
                    volume * this.volumes.engine * this.volumes.master,
                    this.context.currentTime
                );
            }
            
            updateAmbientSound(windSpeed, precipitation) {
                if (!this.ambientSound) return;
                
                // Update filter based on wind
                this.ambientSound.filter.frequency.setValueAtTime(
                    200 + windSpeed * 1000,
                    this.context.currentTime
                );
                
                // Update volume based on weather
                const volume = 0.3 + precipitation * 0.2 + windSpeed * 0.1;
                this.ambientSound.gain.gain.setValueAtTime(
                    volume * this.volumes.ambient * this.volumes.master,
                    this.context.currentTime
                );
            }
            
            playTireScreech(slipRatio, speed) {
                if (Math.abs(slipRatio) > 0.2 && speed > 5) {
                    // Create tire screech sound
                    const oscillator = this.context.createOscillator();
                    const gain = this.context.createGain();
                    
                    oscillator.connect(gain);
                    gain.connect(this.context.destination);
                    
                    oscillator.type = 'square';
                    oscillator.frequency.value = 600 + Math.random() * 400;
                    gain.gain.value = Math.min(0.3, Math.abs(slipRatio) * 0.5);
                    
                    oscillator.start();
                    oscillator.stop(this.context.currentTime + 0.5);
                }
            }
            
            playCollision(force) {
                // Play collision sound
                const oscillator = this.context.createOscillator();
                const gain = this.context.createGain();
                
                oscillator.connect(gain);
                gain.connect(this.context.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.value = 100 + force * 10;
                gain.gain.value = Math.min(0.5, force * 0.01);
                
                oscillator.start();
                oscillator.stop(this.context.currentTime + 0.2);
            }
            
            setVolume(type, value) {
                if (this.volumes[type] !== undefined) {
                    this.volumes[type] = value;
                }
            }
        }

        // ============================
        // AI DRIVER SYSTEM
        // ============================
        class AIDriver {
            constructor(car, behavior = 'explore') {
                this.car = car;
                this.behavior = behavior;
                this.aggression = 0.5;
                this.skill = 0.7;
                this.target = new THREE.Vector3(0, 0, 0);
                this.waypoints = [];
                this.currentWaypoint = 0;
                this.reactionTime = 0.2;
                this.lastUpdate = 0;
                
                this.generateWaypoints();
            }
            
            generateWaypoints() {
                // Generate random waypoints for exploration
                for (let i = 0; i < 20; i++) {
                    this.waypoints.push(new THREE.Vector3(
                        (Math.random() - 0.5) * 1000,
                        0,
                        (Math.random() - 0.5) * 1000
                    ));
                }
            }
            
            update(deltaTime, playerPosition) {
                this.lastUpdate += deltaTime;
                if (this.lastUpdate < this.reactionTime) return;
                this.lastUpdate = 0;
                
                switch (this.behavior) {
                    case 'explore':
                        this.updateExploration();
                        break;
                    case 'chase':
                        this.updateChase(playerPosition);
                        break;
                    case 'race':
                        this.updateRace();
                        break;
                    case 'traffic':
                        this.updateTraffic();
                        break;
                }
            }
            
            updateExploration() {
                if (this.waypoints.length === 0) return;
                
                const current = this.waypoints[this.currentWaypoint];
                const distance = this.car.position.distanceTo(current);
                
                if (distance < 50) {
                    this.currentWaypoint = (this.currentWaypoint + 1) % this.waypoints.length;
                }
                
                this.target.copy(current);
                this.driveToTarget();
            }
            
            updateChase(playerPosition) {
                // Chase the player
                this.target.copy(playerPosition);
                
                // Add some prediction based on player velocity
                if (playerCar) {
                    const playerVelocity = playerCar.physics.getVelocity();
                    this.target.add(playerVelocity.clone().multiplyScalar(1.0));
                }
                
                this.driveToTarget();
            }
            
            updateRace() {
                // Follow race line
                // This would use a pre-defined racing line
                this.driveToTarget();
            }
            
            updateTraffic() {
                // Simple traffic behavior
                this.target = this.car.getForwardVector().multiplyScalar(100).add(this.car.position);
                this.driveToTarget();
            }
            
            driveToTarget() {
                const toTarget = new THREE.Vector3().subVectors(this.target, this.car.position);
                const distance = toTarget.length();
                
                if (distance < 1) return;
                
                // Calculate desired direction
                toTarget.normalize();
                const forward = this.car.getForwardVector();
                
                // Calculate steering angle
                const cross = new THREE.Vector3().crossVectors(forward, toTarget);
                const steering = cross.y * this.skill;
                
                // Calculate throttle/brake
                const dot = forward.dot(toTarget);
                let throttle = 0;
                let brake = 0;
                
                if (dot > 0.7) {
                    throttle = Math.min(1, distance / 100) * this.aggression;
                } else if (dot < -0.3) {
                    brake = 0.5;
                } else {
                    // Need to turn around
                    brake = 0.3;
                }
                
                // Apply to car
                this.car.physics.steering = THREE.MathUtils.clamp(steering, -1, 1);
                this.car.physics.throttle = throttle;
                this.car.physics.brake = brake;
            }
        }

        // ============================
        // EVENT & PROGRESSION SYSTEM
        // ============================
        class EventSystem {
            constructor() {
                this.events = [];
                this.activeEvent = null;
                this.eventTimer = 0;
                this.discoveredLocations = new Set();
                
                this.setupEvents();
            }
            
            setupEvents() {
                this.events = [
                    {
                        id: 'welcome',
                        type: 'exploration',
                        name: 'Welcome to Mexico',
                        description: 'Discover the Horizon Festival site',
                        location: new THREE.Vector3(0, 0, 0),
                        radius: 100,
                        completed: false,
                        rewards: { xp: 500, influence: 100, credits: 10000 }
                    },
                    {
                        id: 'city_sprint',
                        type: 'race',
                        name: 'Guanajuato Sprint',
                        description: 'Race through the city streets',
                        location: new THREE.Vector3(300, 0, 300),
                        radius: 150,
                        completed: false,
                        rewards: { xp: 1000, influence: 200, credits: 25000 }
                    },
                    {
                        id: 'mountain_climb',
                        type: 'danger',
                        name: 'Mountain Danger Sign',
                        description: 'Get the longest jump off the mountain',
                        location: new THREE.Vector3(-400, 50, -400),
                        radius: 80,
                        completed: false,
                        rewards: { xp: 750, influence: 150, credits: 15000 }
                    },
                    {
                        id: 'highway_run',
                        type: 'speed',
                        name: 'Highway Speed Trap',
                        description: 'Reach top speed on the highway',
                        location: new THREE.Vector3(0, 0, -500),
                        radius: 100,
                        completed: false,
                        rewards: { xp: 800, influence: 180, credits: 20000 }
                    }
                ];
                
                this.activeEvent = this.events[0];
            }
            
            update(playerPosition) {
                // Check for event completion
                if (this.activeEvent && !this.activeEvent.completed) {
                    const distance = playerPosition.distanceTo(this.activeEvent.location);
                    
                    if (distance < this.activeEvent.radius) {
                        this.completeEvent(this.activeEvent);
                    }
                }
                
                // Check for location discovery
                this.events.forEach(event => {
                    if (!event.discovered) {
                        const distance = playerPosition.distanceTo(event.location);
                        if (distance < event.radius * 2) {
                            this.discoverLocation(event);
                        }
                    }
                });
            }
            
            completeEvent(event) {
                event.completed = true;
                
                // Award rewards
                gameState.player.xp += event.rewards.xp;
                gameState.player.influence += event.rewards.influence;
                gameState.player.credits += event.rewards.credits;
                
                // Show notification
                showNotification(`Event Completed: ${event.name}`, 
                    `+${event.rewards.xp} XP, +${event.rewards.credits} Credits`);
                
                // Find next event
                const nextEvent = this.events.find(e => !e.completed);
                if (nextEvent) {
                    this.activeEvent = nextEvent;
                    this.updateUI();
                } else {
                    // All events completed
                    this.activeEvent = null;
                    showNotification('Congratulations!', 'All events completed!');
                }
                
                // Check for level up
                this.checkLevelUp();
            }
            
            discoverLocation(event) {
                if (!event.discovered) {
                    event.discovered = true;
                    this.discoveredLocations.add(event.id);
                    
                    // Award discovery bonus
                    const bonus = 50;
                    gameState.player.xp += bonus;
                    gameState.player.influence += bonus / 2;
                    
                    showNotification('Location Discovered', 
                        `${event.name} - +${bonus} XP`);
                }
            }
            
            checkLevelUp() {
                while (gameState.player.xp >= gameState.player.xpToNextLevel) {
                    gameState.player.level++;
                    gameState.player.xp -= gameState.player.xpToNextLevel;
                    gameState.player.xpToNextLevel = Math.floor(
                        gameState.player.xpToNextLevel * 1.5
                    );
                    
                    showNotification('Level Up!', 
                        `Now Level ${gameState.player.level}`);
                }
            }
            
            updateUI() {
                if (this.activeEvent) {
                    document.getElementById('currentEvent').textContent = this.activeEvent.name;
                    document.getElementById('eventDescription').textContent = this.activeEvent.description;
                    
                    // Calculate progress (simplified)
                    const progress = (this.discoveredLocations.size / this.events.length) * 100;
                    document.getElementById('eventProgressFill').style.width = `${progress}%`;
                }
            }
        }

        // ============================
        // UI SYSTEM
        // ============================
        class UISystem {
            constructor() {
                this.notifications = [];
                this.minimapContext = null;
                this.lastUpdate = 0;
                
                this.setupMinimap();
                this.setupEventListeners();
            }
            
            setupMinimap() {
                const canvas = document.getElementById('minimapCanvas');
                canvas.width = canvas.offsetWidth * 2;
                canvas.height = canvas.offsetHeight * 2;
                this.minimapContext = canvas.getContext('2d');
            }
            
            setupEventListeners() {
                // Keyboard controls
                window.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    gameState.input.keys[key] = true;
                    
                    // Special keys
                    if (key === 'escape') togglePause();
                    if (key === 'm') toggleMap();
                    if (key === 'c') toggleCamera();
                    if (key === 'p') togglePhotoMode();
                    if (key === 'f1') togglePerformanceStats();
                });
                
                window.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    gameState.input.keys[key] = false;
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.onResize();
                });
                
                // Prevent context menu
                document.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
                
                // Check for mobile
                this.checkMobile();
            }
            
            checkMobile() {
                gameState.input.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                if (gameState.input.isMobile) {
                    document.getElementById('mobileControls').style.display = 'flex';
                    document.getElementById('controlsPanel').style.display = 'none';
                }
            }
            
            onResize() {
                if (camera && renderer) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    
                    if (composer) {
                        composer.setSize(window.innerWidth, window.innerHeight);
                    }
                }
            }
            
            update(deltaTime, playerCar, gameState) {
                this.lastUpdate += deltaTime;
                if (this.lastUpdate < 0.016) return; // ~60 FPS UI updates
                this.lastUpdate = 0;
                
                // Update speedometer
                if (playerCar) {
                    const speed = playerCar.physics.getVelocity().length() * 3.6; // km/h
                    document.getElementById('currentSpeed').textContent = Math.round(speed);
                    
                    // Update gear
                    const gear = playerCar.physics.currentGear;
                    let gearText = 'N';
                    if (gear > 0) gearText = gear.toString();
                    else if (gear < 0) gearText = 'R';
                    document.getElementById('currentGear').textContent = gearText;
                    
                    // Update RPM bar
                    const rpmPercent = playerCar.physics.rpm / playerCar.physics.params.engine.maxRPM;
                    document.getElementById('rpmFill').style.width = `${rpmPercent * 100}%`;
                }
                
                // Update player stats
                document.getElementById('playerLevel').textContent = gameState.player.level;
                document.getElementById('playerInfluence').textContent = gameState.player.influence.toLocaleString();
                document.getElementById('playerCredits').textContent = gameState.player.credits.toLocaleString();
                
                // Update game time
                const time = gameState.world.time;
                const hours = Math.floor(time);
                const minutes = Math.floor((time % 1) * 60);
                const ampm = hours >= 12 ? 'PM' : 'AM';
                const displayHours = hours % 12 || 12;
                document.getElementById('gameTime').textContent = 
                    `${displayHours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')} ${ampm}`;
                
                // Update weather
                document.getElementById('gameWeather').textContent = 
                    gameState.world.weather.toUpperCase();
                
                // Update damage
                document.getElementById('carDamage').textContent = 
                    `${Math.round(100 - gameState.car.health)}%`;
                
                // Update minimap
                this.updateMinimap(playerCar);
                
                // Update notifications
                this.updateNotifications(deltaTime);
            }
            
            updateMinimap(playerCar) {
                if (!this.minimapContext || !playerCar) return;
                
                const ctx = this.minimapContext;
                const canvas = ctx.canvas;
                
                // Clear
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw background
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw terrain
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = 0.1;
                
                // Draw player
                const playerX = centerX + playerCar.physics.position.x * scale;
                const playerY = centerY + playerCar.physics.position.z * scale;
                
                ctx.fillStyle = '#4cc9f0';
                ctx.beginPath();
                ctx.arc(playerX, playerY, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw player direction
                const forward = playerCar.physics.getForwardVector();
                const dirX = playerX + forward.x * 15;
                const dirY = playerY + forward.z * 15;
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(playerX, playerY);
                ctx.lineTo(dirX, dirY);
                ctx.stroke();
                
                // Draw events
                if (eventSystem) {
                    eventSystem.events.forEach(event => {
                        const eventX = centerX + event.location.x * scale;
                        const eventY = centerY + event.location.z * scale;
                        
                        ctx.fillStyle = event.completed ? '#4ade80' : 
                                       event.discovered ? '#f59e0b' : '#ef4444';
                        
                        ctx.beginPath();
                        ctx.arc(eventX, eventY, 4, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
                
                // Draw location name
                const location = this.getLocationName(playerCar.physics.position);
                document.getElementById('currentLocation').textContent = location;
            }
            
            getLocationName(position) {
                // Simplified location detection
                const x = position.x;
                const z = position.z;
                
                if (Math.abs(x) < 200 && Math.abs(z) < 200) return 'FESTIVAL';
                if (x > 100 && z > 100) return 'GUANAJUATO';
                if (x < -300 || z < -300) return 'MOUNTAINS';
                if (Math.abs(x) < 300 && z < -200) return 'HIGHWAY';
                return 'COUNTRYSIDE';
            }
            
            updateNotifications(deltaTime) {
                // Remove old notifications
                gameState.ui.notifications = gameState.ui.notifications.filter(n => {
                    n.duration -= deltaTime;
                    return n.duration > 0;
                });
                
                // Update notification display
                const container = document.getElementById('notificationCenter');
                container.innerHTML = '';
                
                gameState.ui.notifications.forEach(notification => {
                    const element = document.createElement('div');
                    element.className = 'notification';
                    element.innerHTML = `
                        <div class="notification-title">${notification.title}</div>
                        <div class="notification-message">${notification.message}</div>
                    `;
                    container.appendChild(element);
                });
            }
            
            showNotification(title, message, duration = 3) {
                gameState.ui.notifications.push({
                    title,
                    message,
                    duration
                });
            }
        }

        // ============================
        // INITIALIZATION
        // ============================
        async function initializeGame() {
            // Show loading screen
            updateLoadingProgress('Initializing graphics...', 10);
            
            // Setup Three.js
            setupThreeJS();
            
            updateLoadingProgress('Creating world...', 30);
            
            // Initialize systems
            physicsEngine = new PhysicsEngine();
            terrainSystem = new TerrainSystem();
            weatherSystem = new WeatherSystem();
            audioSystem = new AudioSystem();
            eventSystem = new EventSystem();
            uiSystem = new UISystem();
            
            updateLoadingProgress('Building environment...', 50);
            
            // Create terrain
            createTerrain();
            
            updateLoadingProgress('Adding details...', 70);
            
            // Create environment
            createEnvironment();
            
            updateLoadingProgress('Finalizing...', 90);
            
            // Setup lighting
            setupLighting();
            
            // Setup post-processing
            setupPostProcessing();
            
            updateLoadingProgress('Ready!', 100);
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    showCarSelection();
                }, 500);
            }, 1000);
            
            // Start game loop
            gameLoop();
        }
        
        function setupThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 500, 2000);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                5000
            );
            camera.position.set(0, 10, 20);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: false,
                powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enabled = false;
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
        }
        
        function createTerrain() {
            // Create terrain mesh from heightmap
            const geometry = new THREE.PlaneGeometry(
                terrainSystem.size,
                terrainSystem.size,
                terrainSystem.resolution - 1,
                terrainSystem.resolution - 1
            );
            
            // Apply height data
            const vertices = geometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];
                vertices[i + 1] = terrainSystem.getHeight(x, z);
            }
            
            geometry.computeVertexNormals();
            
            // Create material
            const material = new THREE.MeshStandardMaterial({
                color: 0x3d9970,
                roughness: 0.8,
                metalness: 0.2,
                side: THREE.DoubleSide
            });
            
            terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            terrain.castShadow = true;
            scene.add(terrain);
        }
        
        function createEnvironment() {
            environment = new THREE.Group();
            
            // Create city buildings
            createCity();
            
            // Create trees
            createVegetation();
            
            // Create roads
            createRoads();
            
            // Create festival site
            createFestivalSite();
            
            scene.add(environment);
        }
        
        function createCity() {
            const buildingGeometry = new THREE.BoxGeometry(20, 40, 20);
            const buildingMaterial = new THREE.MeshStandardMaterial({
                color: 0x95a5a6,
                roughness: 0.7,
                metalness: 0.3
            });
            
            for (let i = 0; i < 50; i++) {
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.set(
                    250 + (i % 5) * 30,
                    20,
                    250 + Math.floor(i / 5) * 30
                );
                building.castShadow = true;
                environment.add(building);
            }
        }
        
        function createVegetation() {
            const treeGeometry = new THREE.ConeGeometry(3, 10, 8);
            const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            
            for (let i = 0; i < 200; i++) {
                const x = (Math.random() - 0.5) * 1800;
                const z = (Math.random() - 0.5) * 1800;
                
                // Don't place trees in city or on roads
                if (Math.abs(x - 250) < 100 && Math.abs(z - 250) < 100) continue;
                if (Math.abs(x) < 100 || Math.abs(z) < 100) continue;
                
                const treeGroup = new THREE.Group();
                
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 2.5;
                treeGroup.add(trunk);
                
                const foliage = new THREE.Mesh(treeGeometry, treeMaterial);
                foliage.position.y = 10;
                treeGroup.add(foliage);
                
                treeGroup.position.set(x, terrainSystem.getHeight(x, z), z);
                environment.add(treeGroup);
            }
        }
        
        function createRoads() {
            const roadGeometry = new THREE.PlaneGeometry(400, 20);
            const roadMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.8,
                metalness: 0.1
            });
            
            // Main road
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.set(0, 0.1, 0);
            environment.add(road);
            
            // Road markings
            const markingGeometry = new THREE.PlaneGeometry(2, 0.5);
            const markingMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            for (let i = -200; i < 200; i += 10) {
                const marking = new THREE.Mesh(markingGeometry, markingMaterial);
                marking.rotation.x = -Math.PI / 2;
                marking.position.set(i, 0.11, 0);
                environment.add(marking);
            }
        }
        
        function createFestivalSite() {
            const festivalGeometry = new THREE.CircleGeometry(60, 32);
            const festivalMaterial = new THREE.MeshStandardMaterial({
                color: 0xf59e0b,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            const festival = new THREE.Mesh(festivalGeometry, festivalMaterial);
            festival.rotation.x = -Math.PI / 2;
            festival.position.set(0, 0.05, 0);
            environment.add(festival);
            
            // Flags
            const flagGeometry = new THREE.PlaneGeometry(5, 15);
            const flagMaterial = new THREE.MeshStandardMaterial({
                color: 0x4cc9f0,
                side: THREE.DoubleSide
            });
            
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const flag = new THREE.Mesh(flagGeometry, flagMaterial);
                flag.position.set(
                    Math.cos(angle) * 65,
                    7.5,
                    Math.sin(angle) * 65
                );
                flag.rotation.y = -angle;
                environment.add(flag);
            }
        }
        
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // Main directional light (sun)
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(100, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            scene.add(sunLight);
            
            // Sky light
            const skyLight = new THREE.HemisphereLight(0x87CEEB, 0x3d9970, 0.3);
            scene.add(skyLight);
        }
        
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // Bloom effect
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.5, // strength
                0.4, // radius
                0.85 // threshold
            );
            composer.addPass(bloomPass);
            
            // Film grain
            filmPass = new FilmPass(
                0.05, // noise intensity
                0.5, // scanline intensity
                648, // scanline count
                false // grayscale
            );
            composer.addPass(filmPass);
        }

        // ============================
        // CAR CREATION
        // ============================
        function createCar(type) {
            const carGroup = new THREE.Group();
            
            // Create physics model
            const physicsModel = new CarPhysicsModel(type);
            
            // Create visual model
            createCarVisual(carGroup, type);
            
            // Add to physics engine
            physicsEngine.addRigidBody(physicsModel);
            
            return {
                group: carGroup,
                physics: physicsModel,
                visual: carGroup
            };
        }
        
        function createCarVisual(group, type) {
            // Car body
            const bodyGeometry = new THREE.BoxGeometry(4.5, 1.2, 4.8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: type === 'street' ? 0x3498db : 
                       type === 'offroad' ? 0xe74c3c : 0xf1c40f,
                roughness: 0.4,
                metalness: 0.6
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            group.add(body);
            
            // Windows
            const windowGeometry = new THREE.BoxGeometry(4.0, 0.6, 2.3);
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x1e293b,
                roughness: 0.1,
                metalness: 0.9,
                transparent: true,
                opacity: 0.3
            });
            const windows = new THREE.Mesh(windowGeometry, windowMaterial);
            windows.position.z = 0.8;
            windows.position.y = 1.6;
            group.add(windows);
            
            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);
            const tireMaterial = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.9,
                metalness: 0.1
            });
            
            const wheelPositions = [
                [1.5, -0.6, 1.5],   // Front right
                [-1.5, -0.6, 1.5],  // Front left
                [1.5, -0.6, -1.5],  // Rear right
                [-1.5, -0.6, -1.5]  // Rear left
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, tireMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos[0], pos[1], pos[2]);
                wheel.castShadow = true;
                group.add(wheel);
            });
            
            // Lights
            const lightGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const headlightMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFCC });
            const taillightMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
            
            // Headlights
            const headlight1 = new THREE.Mesh(lightGeometry, headlightMaterial);
            headlight1.position.set(1.2, 0.2, 2.4);
            group.add(headlight1);
            
            const headlight2 = new THREE.Mesh(lightGeometry, headlightMaterial);
            headlight2.position.set(-1.2, 0.2, 2.4);
            group.add(headlight2);
            
            // Taillights
            const taillight1 = new THREE.Mesh(lightGeometry, taillightMaterial);
            taillight1.position.set(1.2, 0.2, -2.4);
            group.add(taillight1);
            
            const taillight2 = new THREE.Mesh(lightGeometry, taillightMaterial);
            taillight2.position.set(-1.2, 0.2, -2.4);
            group.add(taillight2);
            
            group.castShadow = true;
            group.receiveShadow = true;
            scene.add(group);
        }

        // ============================
        // GAME LOOP
        // ============================
        let lastTime = 0;
        let frameCount = 0;
        let lastFPSUpdate = 0;
        
        function gameLoop(time = 0) {
            requestAnimationFrame(gameLoop);
            
            const deltaTime = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;
            
            // Update performance stats
            updatePerformanceStats(time, deltaTime);
            
            // Skip update if paused
            if (gameState.ui.paused) {
                renderFrame();
                return;
            }
            
            // Update game state
            updateGameState(deltaTime);
            
            // Update physics
            if (physicsEngine && playerCar) {
                // Get player inputs
                const inputs = getPlayerInputs();
                
                // Update physics
                physicsEngine.update(deltaTime, playerCar.physics, inputs);
                
                // Update car visual position
                updateCarVisual(playerCar);
            }
            
            // Update camera
            updateCamera(deltaTime);
            
            // Update weather
            if (weatherSystem) {
                weatherSystem.update(deltaTime);
            }
            
            // Update audio
            if (audioSystem && playerCar) {
                audioSystem.updateEngineSound(
                    playerCar.physics.rpm,
                    playerCar.physics.params.engine.maxRPM,
                    playerCar.physics.throttle,
                    playerCar.physics.currentGear,
                    playerCar.physics.getVelocity().length()
                );
                
                audioSystem.updateAmbientSound(
                    gameState.world.wind.speed,
                    weatherSystem.precipitation
                );
            }
            
            // Update events
            if (eventSystem && playerCar) {
                eventSystem.update(playerCar.physics.position);
            }
            
            // Update UI
            if (uiSystem) {
                uiSystem.update(deltaTime, playerCar, gameState);
            }
            
            // Update game world time
            gameState.world.time += deltaTime * 0.1; // 10x real-time
            if (gameState.world.time >= 24) {
                gameState.world.time = 0;
            }
            
            // Render frame
            renderFrame();
        }
        
        function updateGameState(deltaTime) {
            // Update play time
            gameState.player.playTime += deltaTime;
            
            // Update distance traveled
            if (playerCar) {
                const speed = playerCar.physics.getVelocity().length();
                gameState.player.distanceTraveled += speed * deltaTime;
            }
            
            // Update car temperature
            if (playerCar) {
                const speed = playerCar.physics.getVelocity().length();
                gameState.car.temperature.engine = 90 + speed * 0.1;
                gameState.car.temperature.tires = 80 + Math.abs(playerCar.physics.steering) * 20;
                gameState.car.temperature.brakes = 100 - playerCar.physics.brake * 50;
            }
            
            // Update wear
            if (playerCar) {
                const wearRate = 0.0001;
                gameState.car.wear.engine += wearRate * playerCar.physics.rpm / 1000;
                gameState.car.wear.tires += wearRate * playerCar.physics.getVelocity().length();
                gameState.car.wear.brakes += wearRate * playerCar.physics.brake * 10;
                gameState.car.wear.suspension += wearRate * Math.abs(playerCar.physics.steering) * 5;
                
                // Update health based on wear
                const totalWear = Object.values(gameState.car.wear).reduce((a, b) => a + b, 0);
                gameState.car.health = Math.max(0, 100 - totalWear * 10);
            }
            
            // Update skill chain
            if (playerCar) {
                const speed = playerCar.physics.getVelocity().length();
                const isDrifting = Math.abs(playerCar.physics.wheels[0].slipAngle) > 0.2;
                
                if (speed > 10 && (isDrifting || Math.abs(playerCar.physics.steering) > 0.3)) {
                    gameState.player.skillChain += deltaTime;
                    gameState.player.maxSkillChain = Math.max(
                        gameState.player.maxSkillChain,
                        gameState.player.skillChain
                    );
                } else {
                    if (gameState.player.skillChain > 5) {
                        // Award XP for skill chain
                        const xp = Math.floor(gameState.player.skillChain * 10);
                        gameState.player.xp += xp;
                        showNotification('Skill Chain!', `+${xp} XP`);
                    }
                    gameState.player.skillChain = 0;
                }
            }
        }
        
        function getPlayerInputs() {
            const keys = gameState.input.keys;
            
            return {
                throttle: (keys['w'] || keys['arrowup'] || gameState.input.throttle > 0) ? 1 : 0,
                brake: (keys['s'] || keys['arrowdown'] || gameState.input.brake > 0) ? 1 : 0,
                steering: gameState.input.steering,
                handbrake: (keys[' '] || gameState.input.handbrake > 0) ? 1 : 0
            };
        }
        
        function updateCarVisual(car) {
            if (!car) return;
            
            // Update group position and rotation
            car.group.position.copy(car.physics.position);
            car.group.quaternion.copy(car.physics.rotation);
            
            // Update wheel rotation (simplified)
            const wheels = car.group.children.filter(child => 
                child.geometry && child.geometry.type === 'CylinderGeometry'
            );
            
            const speed = car.physics.getVelocity().length();
            const wheelRotation = speed * 10;
            
            wheels.forEach((wheel, index) => {
                wheel.rotation.x += wheelRotation;
                
                // Steering for front wheels
                if (index < 2) {
                    wheel.rotation.y = car.physics.steering * 0.5;
                }
            });
        }
        
        function updateCamera(deltaTime) {
            if (!playerCar || !camera) return;
            
            const carPos = playerCar.physics.position;
            const carForward = playerCar.physics.getForwardVector();
            
            switch (gameState.ui.cameraMode) {
                case 'chase':
                    const chaseOffset = new THREE.Vector3(0, 3, -10);
                    const chasePos = carPos.clone().add(chaseOffset);
                    camera.position.lerp(chasePos, deltaTime * 5);
                    camera.lookAt(carPos.clone().add(new THREE.Vector3(0, 1, 5)));
                    break;
                    
                case 'bumper':
                    const bumperOffset = new THREE.Vector3(0, 1, 2);
                    const bumperPos = carPos.clone().add(
                        carForward.clone().multiplyScalar(bumperOffset.z)
                    );
                    bumperPos.y += bumperOffset.y;
                    camera.position.copy(bumperPos);
                    camera.lookAt(carPos.clone().add(carForward.clone().multiplyScalar(10)));
                    break;
                    
                case 'hood':
                    const hoodOffset = new THREE.Vector3(0, 2, 3);
                    const hoodPos = carPos.clone().add(
                        carForward.clone().multiplyScalar(hoodOffset.z)
                    );
                    hoodPos.y += hoodOffset.y;
                    camera.position.copy(hoodPos);
                    camera.lookAt(carPos.clone().add(carForward.clone().multiplyScalar(20)));
                    break;
                    
                case 'cockpit':
                    const cockpitOffset = new THREE.Vector3(0, 1.5, 0.5);
                    const cockpitPos = carPos.clone().add(
                        carForward.clone().multiplyScalar(cockpitOffset.z)
                    );
                    cockpitPos.y += cockpitOffset.y;
                    camera.position.copy(cockpitPos);
                    camera.lookAt(carPos.clone().add(carForward.clone().multiplyScalar(5)));
                    break;
                    
                case 'orbit':
                    controls.enabled = true;
                    controls.target.copy(carPos);
                    controls.update();
                    break;
            }
        }
        
        function updatePerformanceStats(time, deltaTime) {
            frameCount++;
            
            if (time - lastFPSUpdate >= 1000) {
                gameState.performance.fps = Math.round(frameCount * 1000 / (time - lastFPSUpdate));
                gameState.performance.frameTime = deltaTime * 1000;
                
                frameCount = 0;
                lastFPSUpdate = time;
                
                // Update stats display if visible
                if (document.getElementById('performanceStats').style.display === 'block') {
                    document.getElementById('statFPS').textContent = gameState.performance.fps;
                    document.getElementById('statLatency').textContent = 
                        `${gameState.performance.frameTime.toFixed(1)}ms`;
                    
                    // Get render info
                    const info = renderer.info;
                    document.getElementById('statTriangles').textContent = 
                        info.render.triangles.toLocaleString();
                    document.getElementById('statMemory').textContent = 
                        `${Math.round(info.memory.geometries / 1024)}MB`;
                }
            }
        }
        
        function renderFrame() {
            if (gameState.ui.photoMode) {
                // Apply photo mode effects
                filmPass.uniforms['nIntensity'].value = 0.1;
                filmPass.uniforms['sIntensity'].value = 0.5;
            } else {
                filmPass.uniforms['nIntensity'].value = 0.05;
                filmPass.uniforms['sIntensity'].value = 0.0;
            }
            
            if (composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // ============================
        // UI FUNCTIONS
        // ============================
        function showCarSelection() {
            document.getElementById('carSelection').style.display = 'flex';
        }
        
        function selectCar(type) {
            gameState.car.type = type;
            playerCar = createCar(type);
            
            document.getElementById('carSelection').style.display = 'none';
            
            showNotification('Welcome to Horizon!', 
                `You're driving a ${type === 'street' ? 'Sports Coupe' : 
                type === 'offroad' ? 'Off-Road SUV' : 'Hyper Car'}`);
            
            // Start event system
            eventSystem.updateUI();
        }
        
        function togglePause() {
            gameState.ui.paused = !gameState.ui.paused;
            document.getElementById('pauseMenu').style.display = 
                gameState.ui.paused ? 'flex' : 'none';
            
            if (gameState.ui.paused) {
                controls.enabled = true;
            } else {
                controls.enabled = gameState.ui.cameraMode === 'orbit';
            }
        }
        
        function toggleCamera() {
            const modes = ['chase', 'bumper', 'hood', 'cockpit', 'orbit'];
            const currentIndex = modes.indexOf(gameState.ui.cameraMode);
            gameState.ui.cameraMode = modes[(currentIndex + 1) % modes.length];
            
            controls.enabled = gameState.ui.cameraMode === 'orbit';
            
            showNotification('Camera', `Mode: ${gameState.ui.cameraMode.toUpperCase()}`);
        }
        
        function toggleMap() {
            const map = document.getElementById('minimapContainer');
            map.style.display = map.style.display === 'none' ? 'block' : 'none';
        }
        
        function togglePhotoMode() {
            gameState.ui.photoMode = !gameState.ui.photoMode;
            showNotification('Photo Mode', 
                gameState.ui.photoMode ? 'ON - Press P again to exit' : 'OFF');
        }
        
        function togglePerformanceStats() {
            const stats = document.getElementById('performanceStats');
            stats.style.display = stats.style.display === 'none' ? 'block' : 'none';
        }
        
        function showNotification(title, message, duration = 3) {
            if (uiSystem) {
                uiSystem.showNotification(title, message, duration);
            }
        }
        
        function updateLoadingProgress(text, percent) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingProgress').style.width = `${percent}%`;
        }
        
        function toggleDifficulty() {
            const difficulties = ['easy', 'normal', 'hard', 'expert'];
            const current = GameConfig.gameplay.difficulty;
            const index = difficulties.indexOf(current);
            GameConfig.gameplay.difficulty = difficulties[(index + 1) % difficulties.length];
            
            document.getElementById('difficultyText').textContent = 
                GameConfig.gameplay.difficulty.toUpperCase();
        }
        
        function toggleAssists() {
            GameConfig.gameplay.assists.tractionControl = 
                !GameConfig.gameplay.assists.tractionControl;
            
            document.getElementById('assistsText').textContent = 
                GameConfig.gameplay.assists.tractionControl ? 'ON' : 'OFF';
        }
        
        function startAITest() {
            showNotification('AI Test Drive', 'Starting AI-controlled test drive...');
            // This would start an AI-controlled demo
        }

        // ============================
        // MOBILE CONTROLS
        // ============================
        let steeringActive = false;
        let steeringStartX = 0;
        
        function startSteering(event) {
            steeringActive = true;
            const touch = event.touches[0];
            const rect = event.target.getBoundingClientRect();
            steeringStartX = touch.clientX - rect.left;
            updateSteering(event);
        }
        
        function updateSteering(event) {
            if (!steeringActive) return;
            
            const touch = event.touches[0];
            const rect = event.target.getBoundingClientRect();
            const currentX = touch.clientX - rect.left;
            
            const delta = currentX - steeringStartX;
            const maxDelta = rect.width / 2;
            
            gameState.input.steering = THREE.MathUtils.clamp(delta / maxDelta, -1, 1);
            
            // Update visual
            const stick = document.querySelector('.stick-handle');
            if (stick) {
                const offsetX = gameState.input.steering * 30;
                stick.style.transform = `translateX(${offsetX}px)`;
            }
        }
        
        function resetSteering() {
            steeringActive = false;
            gameState.input.steering = 0;
            
            const stick = document.querySelector('.stick-handle');
            if (stick) {
                stick.style.transform = 'translateX(0)';
            }
        }
        
        function mobileKeyDown(key) {
            gameState.input.keys[key] = true;
        }
        
        function mobileKeyUp(key) {
            gameState.input.keys[key] = false;
        }

        // ============================
        // PAUSE MENU FUNCTIONS
        // ============================
        function restartEvent() {
            showNotification('Event Restarted', 'Returning to start...');
            togglePause();
            
            // Reset car position
            if (playerCar) {
                playerCar.physics.position.set(0, 3, 0);
                playerCar.physics.rotation.set(0, 0, 0, 1);
                playerCar.physics.reset();
            }
        }
        
        function changeCar() {
            togglePause();
            showCarSelection();
            
            // Remove current car from scene
            if (playerCar) {
                scene.remove(playerCar.group);
                playerCar = null;
            }
        }
        
        function showSettings() {
            // This would open a settings menu
            showNotification('Settings', 'Settings menu would open here');
        }
        
        function quitToMenu() {
            togglePause();
            showCarSelection();
            
            // Reset game state
            gameState.player = {
                level: 1,
                xp: 0,
                xpToNextLevel: 1000,
                influence: 0,
                credits: 50000,
                skillChain: 0,
                maxSkillChain: 0,
                playTime: 0,
                distanceTraveled: 0
            };
            
            // Remove current car
            if (playerCar) {
                scene.remove(playerCar.group);
                playerCar = null;
            }
            
            // Reset event system
            eventSystem.setupEvents();
        }

        // ============================
        // PYTHON AI BACKEND SIMULATION
        // ============================
        // Note: This would normally run on a server with Python
        // Here's a simulation of what the Python AI backend would do
        
        class PythonAIBackend {
            constructor() {
                this.analysis = {
                    playerSkill: 0.5,
                    preferredRoutes: [],
                    commonMistakes: [],
                    optimalTimes: {},
                    difficultyAdjustment: 1.0
                };
                
                this.startAIAnalysis();
            }
            
            startAIAnalysis() {
                // Simulated AI analysis that would run on Python backend
                setInterval(() => {
                    this.analyzePlayerPerformance();
                }, 5000);
            }
            
            analyzePlayerPerformance() {
                if (!playerCar) return;
                
                // Analyze driving patterns
                const speed = playerCar.physics.getVelocity().length();
                const steering = Math.abs(playerCar.physics.steering);
                const throttle = playerCar.physics.throttle;
                const brake = playerCar.physics.brake;
                
                // Calculate skill level
                const smoothness = 1 - (steering * throttle * 0.5);
                const control = 1 - (brake * 0.3);
                const aggression = speed / 50; // Normalized
                
                this.analysis.playerSkill = (smoothness + control + aggression) / 3;
                
                // Adjust AI difficulty based on player skill
                this.analysis.difficultyAdjustment = 0.5 + this.analysis.playerSkill * 0.5;
                
                // Log for debugging
                console.log(`AI Analysis: Skill=${this.analysis.playerSkill.toFixed(2)}, ` +
                           `Difficulty=${this.analysis.difficultyAdjustment.toFixed(2)}`);
            }
            
            generateOptimalRaceLine(trackPoints) {
                // This would use machine learning to generate optimal racing lines
                // Simulated implementation
                return trackPoints.map(point => ({
                    x: point.x + (Math.random() - 0.5) * 2,
                    z: point.z + (Math.random() - 0.5) * 2,
                    speed: 30 + Math.random() * 50
                }));
            }
            
            predictPlayerBehavior(timeWindow) {
                // Predict where player will be in the future
                if (!playerCar) return null;
                
                const currentPos = playerCar.physics.position.clone();
                const velocity = playerCar.physics.getVelocity();
                const forward = playerCar.physics.getForwardVector();
                
                // Simple prediction
                return {
                    position: currentPos.add(velocity.clone().multiplyScalar(timeWindow)),
                    speed: velocity.length(),
                    direction: forward
                };
            }
            
            optimizeGameDifficulty() {
                // Dynamically adjust game difficulty
                const currentDifficulty = GameConfig.gameplay.difficulty;
                const targetDifficulty = this.getOptimalDifficulty();
                
                if (currentDifficulty !== targetDifficulty) {
                    GameConfig.gameplay.difficulty = targetDifficulty;
                    showNotification('Dynamic Difficulty', 
                        `Adjusted to ${targetDifficulty.toUpperCase()}`);
                }
            }
            
            getOptimalDifficulty() {
                const skill = this.analysis.playerSkill;
                
                if (skill < 0.3) return 'easy';
                if (skill < 0.6) return 'normal';
                if (skill < 0.8) return 'hard';
                return 'expert';
            }
        }

        // Initialize Python AI backend (simulated)
        const pythonAI = new PythonAIBackend();

        // ============================
        // START THE GAME
        // ============================
        initializeGame();
    </script>
</body>
</html>